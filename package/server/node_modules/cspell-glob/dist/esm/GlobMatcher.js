import mm from 'micromatch';
import * as Path from 'path';
import { doesRootContainPath, normalizeGlobPatterns, normalizeGlobToRoot } from './globHelper.js';
export class GlobMatcher {
    /**
     * @param filename full path of file to match against.
     * @returns a GlobMatch - information about the match.
     */
    matchEx;
    path;
    patterns;
    patternsNormalizedToRoot;
    root;
    dot;
    options;
    constructor(patterns, rootOrOptions, _nodePath) {
        _nodePath = _nodePath ?? Path;
        const options = typeof rootOrOptions === 'string' ? { root: rootOrOptions } : rootOrOptions ?? {};
        const { mode = 'exclude' } = options;
        const isExcludeMode = mode !== 'include';
        _nodePath = options.nodePath ?? _nodePath;
        const { root = _nodePath.resolve(), dot = isExcludeMode, nodePath = _nodePath, nested = isExcludeMode, cwd = process.cwd(), nobrace, } = options;
        const normalizedRoot = nodePath.resolve(nodePath.normalize(root));
        this.options = { root: normalizedRoot, dot, nodePath, nested, mode, nobrace, cwd };
        patterns = Array.isArray(patterns)
            ? patterns
            : typeof patterns === 'string'
                ? patterns.split(/\r?\n/g)
                : [patterns];
        const globPatterns = normalizeGlobPatterns(patterns, this.options);
        this.patternsNormalizedToRoot = globPatterns
            .map((g) => normalizeGlobToRoot(g, normalizedRoot, nodePath))
            // Only keep globs that do not match the root when using exclude mode.
            .filter((g) => nodePath.relative(g.root, normalizedRoot) === '');
        this.patterns = globPatterns;
        this.root = normalizedRoot;
        this.path = nodePath;
        this.dot = dot;
        this.matchEx = buildMatcherFn(this.patterns, this.options);
    }
    /**
     * Check to see if a filename matches any of the globs.
     * If filename is relative, it is considered relative to the root.
     * If filename is absolute and contained within the root, it will be made relative before being tested for a glob match.
     * If filename is absolute and not contained within the root, it will be tested as is.
     * @param filename full path of the file to check.
     */
    match(filename) {
        return this.matchEx(filename).matched;
    }
}
/**
 * This function attempts to emulate .gitignore functionality as much as possible.
 *
 * The resulting matcher function: (filename: string) => GlobMatch
 *
 * If filename is relative, it is considered relative to the root.
 * If filename is absolute and contained within the root, it will be made relative before being tested for a glob match.
 * If filename is absolute and not contained within the root, it will return a GlobMatchNoRule.
 *
 * @param patterns - the contents of a .gitignore style file or an array of individual glob rules.
 * @param options - defines root and other options
 * @returns a function given a filename returns true if it matches.
 */
function buildMatcherFn(patterns, options) {
    const { nodePath: path, dot, nobrace } = options;
    const makeReOptions = { dot, nobrace };
    const rules = patterns
        .map((pattern, index) => ({ pattern, index }))
        .filter((r) => !!r.pattern.glob)
        .filter((r) => !r.pattern.glob.startsWith('#'))
        .map(({ pattern, index }) => {
        const matchNeg = pattern.glob.match(/^!/);
        const glob = pattern.glob.replace(/^!/, '');
        const isNeg = (matchNeg && matchNeg[0].length & 1 && true) || false;
        const reg = mm.makeRe(glob, makeReOptions);
        const fn = (filename) => {
            reg.lastIndex = 0;
            return reg.test(filename);
        };
        return { pattern, index, isNeg, fn, reg };
    });
    const negRules = rules.filter((r) => r.isNeg);
    const posRules = rules.filter((r) => !r.isNeg);
    // const negRegEx = negRules.map((r) => r.reg).map((r) => r.toString());
    // const posRegEx = posRules.map((r) => r.reg).map((r) => r.toString());
    // console.error('buildMatcherFn %o', { negRegEx, posRegEx, stack: new Error().stack });
    // const negReg = joinRegExp(negRegEx);
    // const posReg = joinRegExp(posRegEx);
    const fn = (filename) => {
        filename = path.resolve(path.normalize(filename));
        const fNameNormalize = path.sep === '\\' ? filename.replace(/\\/g, '/') : filename;
        let lastRoot = '!!!!!!';
        let lastRel = '';
        function relativeToRoot(root) {
            if (root !== lastRoot) {
                lastRoot = root;
                const relName = path.relative(root, filename);
                lastRel = path.sep === '\\' ? relName.replace(/\\/g, '/') : relName;
            }
            return lastRel;
        }
        function testRules(rules, matched) {
            for (const rule of rules) {
                const pattern = rule.pattern;
                const root = pattern.root;
                const isRelPat = !pattern.isGlobalPattern;
                if (isRelPat && !doesRootContainPath(root, filename, path)) {
                    continue;
                }
                const fname = isRelPat ? relativeToRoot(root) : fNameNormalize;
                if (rule.fn(fname)) {
                    return {
                        matched,
                        glob: pattern.glob,
                        root,
                        pattern,
                        index: rule.index,
                        isNeg: rule.isNeg,
                    };
                }
            }
        }
        return testRules(negRules, false) || testRules(posRules, true) || { matched: false };
    };
    return fn;
}
// function _joinRegExp(patterns: RegExp[]): RegExp | undefined {
//     if (!patterns.length) {
//         return undefined;
//     }
//     const joined = patterns.map((p) => `(?:${p.source})`).join('|');
//     return new RegExp(joined);
// }
//# sourceMappingURL=GlobMatcher.js.map