import type { CSpellIO } from './CSpellIO.js';
import type { BufferEncoding, DirEntry, Disposable, FileReference, FileResource, Stats, TextFileResource } from './models/index.js';
type UrlOrReference = URL | FileReference;
type NextProvider = (url: URL) => VProviderFileSystem | undefined;
export interface VirtualFS extends Disposable {
    registerFileSystemProvider(provider: VFileSystemProvider, ...providers: VFileSystemProvider[]): Disposable;
    /**
     * Get the fs for a given url.
     */
    getFS(url: URL): VFileSystem;
    /**
     * The file system. All requests will first use getFileSystem to get the file system before making the request.
     */
    readonly fs: Required<VFileSystem>;
    /**
     * Clear the cache of file systems.
     */
    reset(): void;
    /**
     * Indicates that logging has been enabled.
     */
    loggingEnabled: boolean;
    enableLogging(value?: boolean): void;
}
export declare enum FSCapabilityFlags {
    None = 0,
    Stat = 1,
    Read = 2,
    Write = 4,
    ReadWrite = 6,
    ReadDir = 8,
    WriteDir = 16,
    ReadWriteDir = 24
}
interface FileSystemProviderInfo {
    name: string;
}
export interface VFileSystem {
    /**
     * Read a file.
     * @param url - URL to read
     * @param encoding - optional encoding
     * @returns A FileResource, the content will not be decoded. Use `.getText()` to get the decoded text.
     */
    readFile(url: UrlOrReference, encoding?: BufferEncoding): Promise<TextFileResource>;
    /**
     * Write a file
     * @param file - the file to write
     */
    writeFile(file: FileResource): Promise<FileReference>;
    /**
     * Get the stats for a url.
     * @param url - Url to fetch stats for.
     */
    stat(url: UrlOrReference): Promise<VfsStat>;
    /**
     * Read the directory entries for a url.
     * The url should end with `/` to indicate a directory.
     * @param url - the url to read the directory entries for.
     */
    readDirectory(url: URL): Promise<VfsDirEntry[]>;
    /**
     * Get the capabilities for a URL.
     * The capabilities can be more restrictive than the general capabilities of the provider.
     * @param url - the url to try
     */
    getCapabilities(url: URL): FSCapabilities;
    /**
     * Information about the provider.
     * It is up to the provider to define what information is available.
     */
    providerInfo: FileSystemProviderInfo;
    /**
     * Indicates that a provider was found for the url.
     */
    hasProvider: boolean;
}
export interface VProviderFileSystem extends Disposable {
    readFile(url: UrlOrReference): Promise<FileResource>;
    writeFile(file: FileResource): Promise<FileReference>;
    /**
     * Information about the provider.
     * It is up to the provider to define what information is available.
     */
    providerInfo: FileSystemProviderInfo;
    stat(url: UrlOrReference): Stats | Promise<Stats>;
    readDirectory(url: URL): Promise<DirEntry[]>;
    /**
     * These are the general capabilities for the provider's file system.
     * It is possible for a provider to support more capabilities for a given url by providing a getCapabilities function.
     */
    capabilities: FSCapabilityFlags;
    /**
     * Get the capabilities for a URL. Make it possible for a provider to support more capabilities for a given url.
     * These capabilities should be more restrictive than the general capabilities.
     * @param url - the url to try
     * @returns the capabilities for the url.
     */
    getCapabilities?: (url: URL) => FSCapabilities;
}
export interface VFileSystemProvider extends Partial<Disposable> {
    /** Name of the Provider */
    name: string;
    /**
     * Get the file system for a given url. The provider is cached based upon the protocol and hostname.
     * @param url - the url to get the file system for.
     * @param next - call this function to get the next provider to try. This is useful for chaining providers that operate on the same protocol.
     */
    getFileSystem(url: URL, next: NextProvider): VProviderFileSystem | undefined;
}
export declare function createVirtualFS(cspellIO?: CSpellIO): VirtualFS;
export declare function getDefaultVirtualFs(): VirtualFS;
export declare class VFSError extends Error {
    constructor(message: string, options?: {
        cause?: unknown;
    });
}
export declare class VFSErrorUnsupportedRequest extends VFSError {
    readonly request: string;
    readonly parameters?: unknown;
    readonly url?: string | undefined;
    constructor(request: string, url?: URL | string, parameters?: unknown);
}
export interface FSCapabilities {
    readonly flags: FSCapabilityFlags;
    readonly readFile: boolean;
    readonly writeFile: boolean;
    readonly readDirectory: boolean;
    readonly writeDirectory: boolean;
    readonly stat: boolean;
}
export declare function fsCapabilities(flags: FSCapabilityFlags): FSCapabilities;
export interface VfsStat extends Stats {
    isDirectory(): boolean;
    isFile(): boolean;
    isUnknown(): boolean;
    isSymbolicLink(): boolean;
}
export interface VfsDirEntry extends DirEntry {
    isDirectory(): boolean;
    isFile(): boolean;
    isUnknown(): boolean;
    isSymbolicLink(): boolean;
}
export {};
//# sourceMappingURL=VirtualFS.d.ts.map