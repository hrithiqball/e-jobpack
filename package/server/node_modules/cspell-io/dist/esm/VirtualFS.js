import { createTextFileResource, urlOrReferenceToUrl } from './common/index.js';
import { getDefaultCSpellIO } from './CSpellIONode.js';
import { FileType } from './models/index.js';
const debug = false;
export var FSCapabilityFlags;
(function (FSCapabilityFlags) {
    FSCapabilityFlags[FSCapabilityFlags["None"] = 0] = "None";
    FSCapabilityFlags[FSCapabilityFlags["Stat"] = 1] = "Stat";
    FSCapabilityFlags[FSCapabilityFlags["Read"] = 2] = "Read";
    FSCapabilityFlags[FSCapabilityFlags["Write"] = 4] = "Write";
    FSCapabilityFlags[FSCapabilityFlags["ReadWrite"] = 6] = "ReadWrite";
    FSCapabilityFlags[FSCapabilityFlags["ReadDir"] = 8] = "ReadDir";
    FSCapabilityFlags[FSCapabilityFlags["WriteDir"] = 16] = "WriteDir";
    FSCapabilityFlags[FSCapabilityFlags["ReadWriteDir"] = 24] = "ReadWriteDir";
})(FSCapabilityFlags || (FSCapabilityFlags = {}));
class CVirtualFS {
    providers = new Set();
    cachedFs = new Map();
    revCacheFs = new Map();
    fs;
    loggingEnabled = debug;
    constructor() {
        this.fs = fsPassThrough((url) => this._getFS(url));
    }
    enableLogging(value) {
        this.loggingEnabled = value ?? true;
    }
    log = console.log;
    logEvent = (event) => {
        if (this.loggingEnabled) {
            const id = event.traceID.toFixed(13).replace(/\d{4}(?=\d)/g, '$&.');
            const msg = event.message ? `\n\t\t${event.message}` : '';
            const method = rPad(`${event.method}-${event.event}`, 16);
            this.log(`${method} ID:${id} ts:${event.ts.toFixed(13)} ${chopUrl(event.url)}${msg}`);
        }
    };
    registerFileSystemProvider(...providers) {
        providers.forEach((provider) => this.providers.add(provider));
        this.reset();
        return {
            dispose: () => {
                for (const provider of providers) {
                    for (const key of this.revCacheFs.get(provider) || []) {
                        this.cachedFs.delete(key);
                    }
                    this.providers.delete(provider) && undefined;
                }
                this.reset();
            },
        };
    }
    getFS(url) {
        return this._getFS(url);
    }
    _getFS(url) {
        const key = `${url.protocol}${url.hostname}`;
        const cached = this.cachedFs.get(key);
        if (cached) {
            return cached;
        }
        const fnNext = (provider, next) => {
            return (url) => {
                let calledNext = false;
                const fs = provider.getFileSystem(url, (_url) => {
                    calledNext = calledNext || url === _url;
                    return next(_url);
                });
                if (fs) {
                    const s = this.revCacheFs.get(provider) || new Set();
                    s.add(key);
                    this.revCacheFs.set(provider, s);
                    return fs;
                }
                if (!calledNext) {
                    return next(url);
                }
                return undefined;
            };
        };
        let next = (_url) => undefined;
        for (const provider of this.providers) {
            next = fnNext(provider, next);
        }
        const fs = new WrappedProviderFs(next(url), this.logEvent);
        this.cachedFs.set(key, fs);
        return fs;
    }
    reset() {
        this.cachedFs.clear();
        this.revCacheFs.clear();
        this.disposeOfCachedFs();
    }
    disposeOfCachedFs() {
        for (const [key, fs] of [...this.cachedFs].reverse()) {
            try {
                WrappedProviderFs.disposeOf(fs);
            }
            catch (e) {
                // continue - we are cleaning up.
            }
            this.cachedFs.delete(key);
        }
        this.cachedFs.clear();
    }
    dispose() {
        this.disposeOfCachedFs();
        const providers = [...this.providers].reverse();
        for (const provider of providers) {
            try {
                provider.dispose?.();
            }
            catch (e) {
                // continue - we are cleaning up.
            }
        }
    }
}
function fsPassThrough(fs) {
    function gfs(ur, name) {
        const url = urlOrReferenceToUrl(ur);
        const f = fs(url);
        if (!f.hasProvider)
            throw new VFSErrorUnsupportedRequest(name, url, ur instanceof URL ? undefined : { url: ur.url.toString(), encoding: ur.encoding });
        return f;
    }
    return {
        providerInfo: { name: 'default' },
        hasProvider: true,
        stat: async (url) => gfs(url, 'stat').stat(url),
        readFile: async (url) => gfs(url, 'readFile').readFile(url),
        writeFile: async (file) => gfs(file, 'writeFile').writeFile(file),
        readDirectory: async (url) => gfs(url, 'readDirectory')
            .readDirectory(url)
            .then((entries) => entries.map((e) => new CVfsDirEntry(e))),
        getCapabilities: (url) => gfs(url, 'getCapabilities').getCapabilities(url),
    };
}
export function createVirtualFS(cspellIO) {
    const cspell = cspellIO || getDefaultCSpellIO();
    const vfs = new CVirtualFS();
    vfs.registerFileSystemProvider(cspellIOToFsProvider(cspell));
    return vfs;
}
function cspellIOToFsProvider(cspellIO) {
    const capabilities = FSCapabilityFlags.Stat | FSCapabilityFlags.ReadWrite | FSCapabilityFlags.ReadDir;
    const capabilitiesHttp = capabilities & ~FSCapabilityFlags.Write & ~FSCapabilityFlags.ReadDir;
    const capMap = {
        'file:': capabilities,
        'http:': capabilitiesHttp,
        'https:': capabilitiesHttp,
    };
    const name = 'CSpellIO';
    const supportedProtocols = new Set(['file:', 'http:', 'https:']);
    const fs = {
        providerInfo: { name },
        stat: (url) => cspellIO.getStat(url),
        readFile: (url) => cspellIO.readFile(url),
        readDirectory: (url) => cspellIO.readDirectory(url),
        writeFile: (file) => cspellIO.writeFile(file.url, file.content),
        dispose: () => undefined,
        capabilities,
        getCapabilities(url) {
            return fsCapabilities(capMap[url.protocol] || FSCapabilityFlags.None);
        },
    };
    return {
        name,
        getFileSystem: (url, _next) => {
            return supportedProtocols.has(url.protocol) ? fs : undefined;
        },
    };
}
let defaultVirtualFs = undefined;
export function getDefaultVirtualFs() {
    if (!defaultVirtualFs) {
        defaultVirtualFs = createVirtualFS();
    }
    return defaultVirtualFs;
}
function wrapError(e) {
    if (e instanceof VFSError)
        return e;
    // return new VFSError(e instanceof Error ? e.message : String(e), { cause: e });
    return e;
}
export class VFSError extends Error {
    constructor(message, options) {
        super(message, options);
    }
}
export class VFSErrorUnsupportedRequest extends VFSError {
    request;
    parameters;
    url;
    constructor(request, url, parameters) {
        super(`Unsupported request: ${request}`);
        this.request = request;
        this.parameters = parameters;
        this.url = url?.toString();
    }
}
class CFsCapabilities {
    flags;
    constructor(flags) {
        this.flags = flags;
    }
    get readFile() {
        return !!(this.flags & FSCapabilityFlags.Read);
    }
    get writeFile() {
        return !!(this.flags & FSCapabilityFlags.Write);
    }
    get readDirectory() {
        return !!(this.flags & FSCapabilityFlags.ReadDir);
    }
    get writeDirectory() {
        return !!(this.flags & FSCapabilityFlags.WriteDir);
    }
    get stat() {
        return !!(this.flags & FSCapabilityFlags.Stat);
    }
}
export function fsCapabilities(flags) {
    return new CFsCapabilities(flags);
}
class WrappedProviderFs {
    fs;
    eventLogger;
    hasProvider;
    capabilities;
    providerInfo;
    _capabilities;
    constructor(fs, eventLogger) {
        this.fs = fs;
        this.eventLogger = eventLogger;
        this.hasProvider = !!fs;
        this.capabilities = fs?.capabilities || FSCapabilityFlags.None;
        this._capabilities = fsCapabilities(this.capabilities);
        this.providerInfo = fs?.providerInfo || { name: 'unknown' };
    }
    logEvent(method, event, traceID, url, message) {
        this.eventLogger({ method, event, url, traceID, ts: performance.now(), message });
    }
    getCapabilities(url) {
        if (this.fs?.getCapabilities)
            return this.fs.getCapabilities(url);
        return this._capabilities;
    }
    async stat(urlRef) {
        const traceID = performance.now();
        const url = urlOrReferenceToUrl(urlRef);
        this.logEvent('stat', 'start', traceID, url);
        try {
            checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Stat, 'stat', url);
            return new CVfsStat(await this.fs.stat(urlRef));
        }
        catch (e) {
            this.logEvent('stat', 'error', traceID, url, e instanceof Error ? e.message : '');
            throw wrapError(e);
        }
        finally {
            this.logEvent('stat', 'end', traceID, url);
        }
    }
    async readFile(urlRef, encoding) {
        const traceID = performance.now();
        const url = urlOrReferenceToUrl(urlRef);
        this.logEvent('readFile', 'start', traceID, url);
        try {
            checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Read, 'readFile', url);
            return createTextFileResource(await this.fs.readFile(urlRef), encoding);
        }
        catch (e) {
            this.logEvent('readFile', 'error', traceID, url, e instanceof Error ? e.message : '');
            throw wrapError(e);
        }
        finally {
            this.logEvent('readFile', 'end', traceID, url);
        }
    }
    async readDirectory(url) {
        const traceID = performance.now();
        this.logEvent('readDir', 'start', traceID, url);
        try {
            checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.ReadDir, 'readDirectory', url);
            return (await this.fs.readDirectory(url)).map((e) => new CVfsDirEntry(e));
        }
        catch (e) {
            this.logEvent('readDir', 'error', traceID, url, e instanceof Error ? e.message : '');
            throw wrapError(e);
        }
        finally {
            this.logEvent('readDir', 'end', traceID, url);
        }
    }
    async writeFile(file) {
        const traceID = performance.now();
        const url = file.url;
        this.logEvent('writeFile', 'start', traceID, url);
        try {
            checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Write, 'writeFile', file.url);
            return await this.fs.writeFile(file);
        }
        catch (e) {
            this.logEvent('writeFile', 'error', traceID, url, e instanceof Error ? e.message : '');
            throw wrapError(e);
        }
        finally {
            this.logEvent('writeFile', 'end', traceID, url);
        }
    }
    static disposeOf(fs) {
        fs instanceof WrappedProviderFs && fs.fs?.dispose();
    }
}
function checkCapabilityOrThrow(fs, capabilities, flag, name, url) {
    if (!(capabilities & flag)) {
        throw new VFSErrorUnsupportedRequest(name, url);
    }
}
class CFileType {
    fileType;
    constructor(fileType) {
        this.fileType = fileType;
    }
    isFile() {
        return this.fileType === FileType.File;
    }
    isDirectory() {
        return this.fileType === FileType.Directory;
    }
    isUnknown() {
        return !this.fileType;
    }
    isSymbolicLink() {
        return !!(this.fileType & FileType.SymbolicLink);
    }
}
class CVfsStat extends CFileType {
    stat;
    constructor(stat) {
        super(stat.fileType || FileType.Unknown);
        this.stat = stat;
    }
    get size() {
        return this.stat.size;
    }
    get mtimeMs() {
        return this.stat.mtimeMs;
    }
    get eTag() {
        return this.stat.eTag;
    }
}
class CVfsDirEntry extends CFileType {
    entry;
    _url;
    constructor(entry) {
        super(entry.fileType);
        this.entry = entry;
    }
    get name() {
        return this.entry.name;
    }
    get dir() {
        return this.entry.dir;
    }
    get url() {
        if (this._url)
            return this._url;
        this._url = new URL(this.entry.name, this.entry.dir);
        return this._url;
    }
    toJSON() {
        return {
            name: this.name,
            dir: this.dir,
            fileType: this.fileType,
        };
    }
}
function chopUrl(url) {
    if (!url)
        return '';
    const href = url.href;
    const parts = href.split('/');
    const n = parts.indexOf('node_modules');
    if (n > 0) {
        const tail = parts.slice(Math.max(parts.length - 3, n + 1));
        return parts.slice(0, n + 1).join('/') + '/…/' + tail.join('/');
    }
    return href;
}
function rPad(str, len, ch = ' ') {
    return str + ch.repeat(Math.max(0, len - str.length));
}
//# sourceMappingURL=VirtualFS.js.map