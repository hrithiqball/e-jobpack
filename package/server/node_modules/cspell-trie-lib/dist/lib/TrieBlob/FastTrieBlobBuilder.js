import { assert } from '../utils/assert.js';
import { mergeOptionalWithDefaults } from '../utils/mergeOptionalWithDefaults.js';
import { FastTrieBlob } from './FastTrieBlob.js';
import { FastTrieBlobInternals } from './FastTrieBlobInternals.js';
import { resolveMap } from './resolveMap.js';
import { TrieBlob } from './TrieBlob.js';
export class FastTrieBlobBuilder {
    charToIndexMap = Object.create(null);
    charIndex = [''];
    nodes;
    _readonly = false;
    IdxEOW;
    _cursor;
    _options;
    bitMasksInfo;
    constructor(options, bitMasksInfo = FastTrieBlobBuilder.DefaultBitMaskInfo) {
        this._options = mergeOptionalWithDefaults(options);
        this.bitMasksInfo = bitMasksInfo;
        this.nodes = [[0], Object.freeze([FastTrieBlobBuilder.NodeMaskEOW])];
        this.IdxEOW = 1;
    }
    setOptions(options) {
        this._options = mergeOptionalWithDefaults(this.options, options);
        return this.options;
    }
    get options() {
        return this._options;
    }
    getCharIndex(char) {
        let idx = this.charToIndexMap[char];
        if (idx)
            return idx;
        const charNFC = char.normalize('NFC');
        const charNFD = char.normalize('NFD');
        idx = this.charIndex.push(charNFC) - 1;
        this.charToIndexMap[charNFC] = idx;
        this.charToIndexMap[charNFD] = idx;
        return idx;
    }
    insert(word) {
        if (this.isReadonly()) {
            throw new Error('FastTrieBlob is readonly');
        }
        if (typeof word === 'string') {
            return this._insert(word);
        }
        const words = word;
        if (Array.isArray(words)) {
            for (let i = 0; i < words.length; ++i) {
                this._insert(words[i]);
            }
            return this;
        }
        for (const w of words) {
            this._insert(w);
        }
        return this;
    }
    getCursor() {
        this._cursor ??= this.createCursor();
        return this._cursor;
    }
    createCursor() {
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
        const LetterMask = this.bitMasksInfo.NodeMaskChildCharIndex;
        function childPos(node, letterIdx) {
            for (let i = 1; i < node.length; ++i) {
                if ((node[i] & LetterMask) === letterIdx) {
                    return i;
                }
            }
            return 0;
        }
        assert(this.nodes.length === 2);
        const eow = 1;
        const eowShifted = eow << NodeChildRefShift;
        const nodes = this.nodes;
        const stack = [{ nodeIdx: 0, pos: 0 }];
        let nodeIdx = 0;
        let depth = 0;
        const insertChar = (char) => {
            // console.warn('i %o at %o', char, nodeIdx);
            if (nodes[nodeIdx] && Object.isFrozen(nodes[nodeIdx])) {
                nodeIdx = nodes.push([...nodes[nodeIdx]]) - 1;
                // fix parent
                const { pos, nodeIdx: pNodeIdx } = stack[depth];
                const pNode = nodes[pNodeIdx];
                // console.warn('fix parent %o', { pNode, pos, pNodeIdx });
                pNode[pos] = (pNode[pos] & LetterMask) | (nodeIdx << NodeChildRefShift);
            }
            const node = nodes[nodeIdx] ?? [0];
            nodes[nodeIdx] = node;
            const letterIdx = this.getCharIndex(char);
            const hasIdx = childPos(node, letterIdx);
            const childIdx = hasIdx ? node[hasIdx] >>> NodeChildRefShift : nodes.length;
            const pos = hasIdx || node.push((childIdx << NodeChildRefShift) | letterIdx) - 1;
            ++depth;
            const s = stack[depth];
            if (s) {
                s.nodeIdx = nodeIdx;
                s.pos = pos;
            }
            else {
                stack[depth] = { nodeIdx, pos };
            }
            nodeIdx = childIdx;
        };
        const markEOW = () => {
            // console.warn('$');
            if (nodeIdx === eow)
                return;
            const node = nodes[nodeIdx];
            if (!node) {
                // no children, set the parent to point to the common EOW.
                const { pos, nodeIdx: pNodeIdx } = stack[depth];
                const pNode = nodes[pNodeIdx];
                pNode[pos] = (pNode[pos] & LetterMask) | eowShifted;
            }
            else {
                nodes[nodeIdx] = node;
                node[0] |= NodeMaskEOW;
            }
            nodeIdx = eow;
        };
        const reference = (nodeId) => {
            const refNodeIdx = nodeId;
            // console.warn('r %o', { nodeId, nodeIdx, refNodeIdx, depth });
            // assert(nodes[nodeIdx] === undefined);
            // assert(nodes[refNodeIdx]);
            Object.freeze(nodes[refNodeIdx]);
            const s = stack[depth];
            nodeIdx = s.nodeIdx;
            const pos = s.pos;
            const node = nodes[nodeIdx];
            node[pos] = (refNodeIdx << NodeChildRefShift) | (node[pos] & LetterMask);
            // depth -= 1;
        };
        const backStep = (num) => {
            if (!num)
                return;
            // console.warn('<< %o', num);
            assert(num <= depth && num > 0);
            depth -= num;
            nodeIdx = stack[depth + 1].nodeIdx;
        };
        const c = {
            insertChar,
            markEOW,
            reference,
            backStep,
        };
        return c;
    }
    _insert(word) {
        word = word.trim();
        if (!word)
            return this;
        const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
        const IdxEOW = this.IdxEOW;
        const nodes = this.nodes;
        const len = word.length;
        let nodeIdx = 0;
        for (let p = 0; p < len; ++p) {
            const letterIdx = this.getCharIndex(word[p]);
            const node = nodes[nodeIdx];
            const count = node.length;
            let i = count - 1;
            for (; i > 0; --i) {
                if ((node[i] & NodeMaskChildCharIndex) === letterIdx) {
                    break;
                }
            }
            if (i > 0) {
                nodeIdx = node[i] >>> NodeChildRefShift;
                if (nodeIdx === 1 && p < len - 1) {
                    nodeIdx = this.nodes.push([NodeMaskEOW]) - 1;
                    node[i] = (nodeIdx << NodeChildRefShift) | letterIdx;
                }
                continue;
            }
            // Not found, add a new node if it isn't the end of the word.
            nodeIdx = p < len - 1 ? this.nodes.push([0]) - 1 : IdxEOW;
            node.push((nodeIdx << NodeChildRefShift) | letterIdx);
        }
        if (nodeIdx > 1) {
            // Make sure the EOW is set
            const node = nodes[nodeIdx];
            node[0] |= NodeMaskEOW;
        }
        return this;
    }
    has(word) {
        const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
        const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
        const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
        const nodes = this.nodes;
        const len = word.length;
        let nodeIdx = 0;
        let node = nodes[nodeIdx];
        for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
            const letterIdx = this.charToIndexMap[word[p]];
            const count = node.length;
            let i = count - 1;
            for (; i > 0; --i) {
                if ((node[i] & NodeMaskChildCharIndex) === letterIdx) {
                    break;
                }
            }
            if (i < 1)
                return false;
            nodeIdx = node[i] >>> NodeChildRefShift;
        }
        return !!(node[0] & NodeMaskEOW);
    }
    isReadonly() {
        return this._readonly;
    }
    freeze() {
        this._readonly = true;
        return this;
    }
    build() {
        this.freeze();
        Object.freeze(this.nodes);
        return FastTrieBlob.create(new FastTrieBlobInternals(this.nodes, this.charIndex, this.charToIndexMap, this.bitMasksInfo), this.options);
    }
    static fromWordList(words, options) {
        const ft = new FastTrieBlobBuilder(options);
        return ft.insert(words).build();
    }
    static fromTrieRoot(root) {
        const bitMasksInfo = FastTrieBlobBuilder.DefaultBitMaskInfo;
        const NodeChildRefShift = bitMasksInfo.NodeChildRefShift;
        const NodeMaskEOW = bitMasksInfo.NodeMaskEOW;
        const tf = new FastTrieBlobBuilder(undefined, bitMasksInfo);
        const IdxEOW = tf.IdxEOW;
        const known = new Map([[root, 0]]);
        function resolveNode(n) {
            if (n.f && !n.c)
                return IdxEOW;
            const node = [n.f ? NodeMaskEOW : 0];
            return tf.nodes.push(node) - 1;
        }
        function walk(n) {
            const found = known.get(n);
            if (found)
                return found;
            const nodeIdx = resolveMap(known, n, resolveNode);
            const node = tf.nodes[nodeIdx];
            if (!n.c)
                return nodeIdx;
            const children = Object.entries(n.c);
            node.length = children.length + 1;
            for (let p = 0; p < children.length; ++p) {
                const [char, childNode] = children[p];
                const letterIdx = tf.getCharIndex(char);
                const childIdx = walk(childNode);
                node[p + 1] = (childIdx << NodeChildRefShift) | letterIdx;
            }
            return nodeIdx;
        }
        walk(root);
        return tf.build();
    }
    static NodeMaskEOW = TrieBlob.NodeMaskEOW;
    static NodeChildRefShift = TrieBlob.NodeChildRefShift;
    static NodeMaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
    static DefaultBitMaskInfo = {
        NodeMaskEOW: FastTrieBlobBuilder.NodeMaskEOW,
        NodeMaskChildCharIndex: FastTrieBlobBuilder.NodeMaskChildCharIndex,
        NodeChildRefShift: FastTrieBlobBuilder.NodeChildRefShift,
    };
}
//# sourceMappingURL=FastTrieBlobBuilder.js.map