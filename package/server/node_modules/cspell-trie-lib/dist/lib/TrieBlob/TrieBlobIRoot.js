export class TrieBlobInternals {
    nodes;
    charIndex;
    charToIndexMap;
    NodeMaskEOW;
    NodeMaskNumChildren;
    NodeMaskChildCharIndex;
    NodeChildRefShift;
    constructor(nodes, charIndex, charToIndexMap, maskInfo) {
        this.nodes = nodes;
        this.charIndex = charIndex;
        this.charToIndexMap = charToIndexMap;
        const { NodeMaskEOW, NodeMaskChildCharIndex, NodeMaskNumChildren, NodeChildRefShift } = maskInfo;
        this.NodeMaskEOW = NodeMaskEOW;
        this.NodeMaskNumChildren = NodeMaskNumChildren;
        this.NodeMaskChildCharIndex = NodeMaskChildCharIndex;
        this.NodeChildRefShift = NodeChildRefShift;
    }
}
const EmptyKeys = Object.freeze([]);
const EmptyNodes = Object.freeze([]);
class TrieBlobINode {
    trie;
    nodeIdx;
    id;
    size;
    node;
    eow;
    _keys;
    charToIdx;
    constructor(trie, nodeIdx) {
        this.trie = trie;
        this.nodeIdx = nodeIdx;
        const node = trie.nodes[nodeIdx];
        this.node = node;
        this.eow = !!(node & trie.NodeMaskEOW);
        this.size = node & trie.NodeMaskNumChildren;
        this.id = nodeIdx;
    }
    /** get keys to children */
    keys() {
        if (this._keys)
            return this._keys;
        if (!this.size)
            return EmptyKeys;
        const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
        const charIndex = this.trie.charIndex;
        const keys = Array(this.size);
        const offset = this.nodeIdx + 1;
        const len = this.size;
        for (let i = 0; i < len; ++i) {
            const entry = this.trie.nodes[i + offset];
            const charIdx = entry & NodeMaskChildCharIndex;
            keys[i] = charIndex[charIdx];
        }
        this._keys = keys;
        return keys;
    }
    values() {
        if (!this.size)
            return EmptyNodes;
        const nodes = Array(this.size);
        for (let i = 0; i < this.size; ++i) {
            nodes[i] = this.child(i);
        }
        return nodes;
    }
    entries() {
        const keys = this.keys();
        const values = this.values();
        const len = keys.length;
        const entries = Array(len);
        for (let i = 0; i < len; ++i) {
            entries[i] = [keys[i], values[i]];
        }
        return entries;
    }
    /** get child ITrieNode */
    get(char) {
        const idx = this.getCharToIdxMap()[char];
        if (idx === undefined)
            return undefined;
        return this.child(idx);
    }
    has(char) {
        const idx = this.getCharToIdxMap()[char];
        return idx !== undefined;
    }
    hasChildren() {
        return this.size > 0;
    }
    child(keyIdx) {
        const n = this.trie.nodes[this.nodeIdx + keyIdx + 1];
        const nodeIdx = n >>> this.trie.NodeChildRefShift;
        return new TrieBlobINode(this.trie, nodeIdx);
    }
    getCharToIdxMap() {
        const m = this.charToIdx;
        if (m)
            return m;
        const map = Object.create(null);
        const keys = this.keys();
        for (let i = 0; i < keys.length; ++i) {
            map[keys[i]] = i;
        }
        this.charToIdx = map;
        return map;
    }
}
export class TrieBlobIRoot extends TrieBlobINode {
    info;
    constructor(trie, nodeIdx, info) {
        super(trie, nodeIdx);
        this.info = info;
    }
    resolveId(id) {
        return new TrieBlobINode(this.trie, id);
    }
}
//# sourceMappingURL=TrieBlobIRoot.js.map