import { FastTrieBlobBuilder } from './FastTrieBlobBuilder.js';
import { resolveMap } from './resolveMap.js';
import { TrieBlob } from './TrieBlob.js';
export function createTrieBlob(words, options) {
    const ft = FastTrieBlobBuilder.fromWordList(words, options);
    return ft.toTrieBlob();
}
export function createTrieBlobFromITrieNodeRoot(root) {
    const NodeMaskEOW = TrieBlob.NodeMaskEOW;
    const NodeChildRefShift = TrieBlob.NodeChildRefShift;
    const NodeMaskNumChildren = TrieBlob.NodeMaskNumChildren;
    const nodes = [];
    const charIndex = [''];
    const charMap = Object.create(null);
    const known = new Map();
    known.set(root.id, appendNode(root));
    const IdxEOW = nodes.push(NodeMaskEOW) - 1;
    function getCharIndex(char) {
        const idx = charMap[char];
        if (idx)
            return idx;
        const newIdx = charIndex.push(char) - 1;
        charMap[char.normalize('NFC')] = newIdx;
        charMap[char.normalize('NFD')] = newIdx;
        return newIdx;
    }
    function appendNode(n) {
        const idx = nodes.push(n.eow ? NodeMaskEOW : 0) - 1;
        if (n.hasChildren()) {
            const keys = n.keys().map((key) => getCharIndex(key));
            nodes[idx] = nodes[idx] | (keys.length & NodeMaskNumChildren);
            nodes.push(...keys);
        }
        return idx;
    }
    function resolveNode(id) {
        const n = root.resolveId(id);
        if (n.eow && !n.hasChildren())
            return IdxEOW;
        return appendNode(n);
    }
    function walk(n) {
        const found = known.get(n.id);
        if (found)
            return found;
        const nodeIdx = resolveMap(known, n.id, resolveNode);
        if (!n.hasChildren())
            return nodeIdx;
        const children = n.values();
        for (let p = 0; p < children.length; ++p) {
            const childNode = children[p];
            const childIdx = walk(childNode);
            // Nodes already have the letters, just OR in the child index.
            nodes[nodeIdx + p + 1] |= childIdx << NodeChildRefShift;
        }
        return nodeIdx;
    }
    walk(root);
    return new TrieBlob(Uint32Array.from(nodes), charIndex, root.info);
}
export function createTrieBlobFromTrieData(trie) {
    return createTrieBlobFromITrieNodeRoot(trie.getRoot());
}
//# sourceMappingURL=createTrieBlob.js.map